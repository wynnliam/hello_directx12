// Liam Wynn, 9/26/2024, Hello DirectX 12

#include "dx12_handler.h"
#include "utils.h"

dx12_handler::dx12_handler() {
	rtv_descriptor_size = 0;
	frame_index = 0;
	fence_event = NULL;
	fence_value = 1;
}

bool initialize_directx_12(
	dx12_handler* dx12,
	HWND hwnd,
	const uint32_t screen_w,
	const uint32_t screen_h,
	const bool use_warp
) {
	ComPtr<IDXGIFactory4> factory;
	ComPtr<IDXGIAdapter4> adapter;

	enable_dx12_debug_layer();

	//
	// Create a DX12 Factory. This is needed to create several DX12 objects.
	//

	factory = create_dx12_factory();

	//
	// Create the DX12 Device.
	//

	// Get the adapter (object that represents the user's
	// graphics rendering hardware).
	adapter = get_valid_adapter(use_warp, factory);

	// Now use the adapter to create the DX12 device. This
	// device is needed to manage all of the resources and
	// memory for DX12 - it's like the GPU's memory context.
	dx12->device = create_dx12_device(adapter);

	//
	// Next, create the command queue.
	//
	
	dx12->command_queue = create_command_queue(dx12->device);

	//
	// Next, create the swap chain.
	//

	dx12->swap_chain = create_swap_chain(
		hwnd,
		screen_w,
		screen_h,
		factory,
		dx12->command_queue
	);

	dx12->frame_index = dx12->swap_chain->GetCurrentBackBufferIndex();

	//
	// Create the render target view descriptor heap.
	//

	dx12->rtv_heap = create_descriptor_heap(
		dx12->device,
		NUM_RENDER_TARGETS,
		D3D12_DESCRIPTOR_HEAP_TYPE_RTV,
		D3D12_DESCRIPTOR_HEAP_FLAG_NONE
	);

	//
	// Create the shader resource view heap for the texture.
	//

	dx12->srv_heap = create_descriptor_heap(
		dx12->device,
		1,
		D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,
		D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE
	);

	//
	// Next, update the render target views.
	//

	update_render_target_views(dx12);

	//
	// Next, create the command allocator.
	//

	dx12->command_allocator = create_command_allocator(
		dx12->device,
		D3D12_COMMAND_LIST_TYPE_DIRECT
	);

	//
	// Next, set up the command list using our command allocator.
	//

	dx12->command_list = create_command_list(
		dx12->device,
		dx12->command_allocator,
		D3D12_COMMAND_LIST_TYPE_DIRECT
	);

	//
	// Finally, create the fence and synchronization objects.
	//

	dx12->fence = create_fence(dx12->device);
	dx12->fence_event = create_fence_event();

	return true;
}

void enable_dx12_debug_layer() {
#if defined(_DEBUG)
	// It is a good idea to enable the debug layer before doing
	// anything else that is DX12 related. This way, all possible
	// errors generated by DX12 are caught.
	ComPtr<ID3D12Debug> debug_interface;
	HRESULT result;

	result = D3D12GetDebugInterface(IID_PPV_ARGS(&debug_interface));
	throw_if_failed(result);

	debug_interface->EnableDebugLayer();

#endif
}

ComPtr<IDXGIFactory4> create_dx12_factory() {
	ComPtr<IDXGIFactory4> dxgi_factory;
	UINT create_factory_flags;
	HRESULT result;

	//
	// Create a DXGI Factory. This factory is responsible
	// for creating any kind of DirectX object.
	//

	create_factory_flags = 0;
	// DXGI_CREATE_FACTORY_DEBUG allows us to catch errors during
	// device creation. However, we only want this enabled when in
	// a debug environment, and not a production one.
#if defined(_DEBUG)
	create_factory_flags = DXGI_CREATE_FACTORY_DEBUG;
#endif

	result = CreateDXGIFactory2(
		create_factory_flags,
		IID_PPV_ARGS(&dxgi_factory)
	);

	throw_if_failed(result);

	return dxgi_factory;
}

ComPtr<IDXGIAdapter4> get_valid_adapter(
	const bool use_warp,
	ComPtr<IDXGIFactory4> factory
) {
	HRESULT result;
	ComPtr<IDXGIAdapter1> dxgi_adapter1;
	ComPtr<IDXGIAdapter4> dxgi_adapter4;
	SIZE_T max_dedicated_video_mem;
	UINT i;
	DXGI_ADAPTER_DESC1 dxgi_adapter_desc1;
	UINT adapter_flags;
	UINT software_flag;
	BOOL is_hardware_adapter;
	BOOL can_create_dx12_device;
	SIZE_T curr_video_mem;
	BOOL has_most_video_mem;

	//
	// Now we use the factory to construct the adapter
	// object.
	//

	if (use_warp) {
		// The EnumWarpAdapter function returns am IDXGIAdapter1 type,
		// and so we need to cast it into an IDXGIAdapter4. The 4 type
		// is a type 1 with more features. I believe the number represents
		// subsequent versions of the Adapter object.
		result = factory->EnumWarpAdapter(IID_PPV_ARGS(&dxgi_adapter1));
		throw_if_failed(result);

		result = dxgi_adapter1.As(&dxgi_adapter4);
		throw_if_failed(result);
	} else {
		max_dedicated_video_mem = 0;
		i = 0;

		// If we don't use a warp device, then we choose the adapter
		// with the largest video memory. This is a naive approach,
		// since it assumes more video memory means a more powerful
		// device. But for our purposes it's good enough.
		while (true) {
			result = factory->EnumAdapters1(i, &dxgi_adapter1);
			if (result == DXGI_ERROR_NOT_FOUND) {
				break;
			}

			result = dxgi_adapter1->GetDesc1(&dxgi_adapter_desc1);
			throw_if_failed(result);

			// The DXGI_ADAPTER_FLAG_SOFTWARE indicates the adapter is a
			// software adapter. We only want hardware adapters. Thus, we
			// check that the DXGI_ADAPTER_FLAG_SOFTWARE is unset.
			adapter_flags = dxgi_adapter_desc1.Flags;
			software_flag = adapter_flags & DXGI_ADAPTER_FLAG_SOFTWARE;
			is_hardware_adapter = software_flag == 0;

			// Attempt to create the device without actually creating it.
			result = D3D12CreateDevice(
				dxgi_adapter1.Get(),
				D3D_FEATURE_LEVEL_11_0,
				__uuidof(ID3D12Device),
				NULL
			);

			can_create_dx12_device = SUCCEEDED(result);

			// Lastly, we want to see that the current device actually
			// has more memory than the last one we looked at.
			curr_video_mem = dxgi_adapter_desc1.DedicatedVideoMemory;
			has_most_video_mem = curr_video_mem > max_dedicated_video_mem;

			// If the current adapter meets all of the requirements, then
			// set that one as dxgi_adapter4.
			if (is_hardware_adapter &&
				can_create_dx12_device &&
				has_most_video_mem)
			{
				max_dedicated_video_mem = curr_video_mem;

				result = dxgi_adapter1.As(&dxgi_adapter4);
				throw_if_failed(result);
			}

			// Don't forget to increment i to look at the next adapter!
			i++;
		}
	}

	return dxgi_adapter4;
}

ComPtr<ID3D12Device> create_dx12_device(ComPtr<IDXGIAdapter4> adapter) {
	ComPtr<ID3D12Device> dev;
	HRESULT result;

#if defined(_DEBUG)
	ComPtr<ID3D12InfoQueue> debug_info;
	D3D12_INFO_QUEUE_FILTER filter;

	D3D12_MESSAGE_SEVERITY ignore_severities[] = {
		// This message severity is for displaying information, and not
		// for any error/warning.
		D3D12_MESSAGE_SEVERITY_INFO
	};

	D3D12_MESSAGE_ID ignore_ids[] = {
		// If a render target is cleared with any arbitrary color,
		// and not the optimized clear color, you will get this
		// warning. Defnitely annoying, but may be worth looking into.
		// I had no idea clear colors needed to be optimized for render
		// targets.
		D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE,
		// These warnings you only get if you are doing debugging in
		// Visual Studio and they are just annoying - I guess?
		D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE,
		D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE
	};

#endif

	// Before we just tried to create a device without actually
	// creating it. This time we actually create the device and
	// keep the result in dev.
	result = D3D12CreateDevice(
		adapter.Get(),
		D3D_FEATURE_LEVEL_11_0,
		IID_PPV_ARGS(&dev)
	);

	throw_if_failed(result);

	//
	// If in debug mode, specify errors/warnings that we want to
	// force the application to break on.
	//

#if defined(_DEBUG)
	result = dev.As(&debug_info);
	if (SUCCEEDED(result)) {
		debug_info->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		debug_info->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
		debug_info->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
	}

	filter = {};
	filter.DenyList.NumSeverities = _countof(ignore_severities);
	filter.DenyList.pSeverityList = ignore_severities;
	filter.DenyList.NumIDs = _countof(ignore_ids);
	filter.DenyList.pIDList = ignore_ids;

	result = debug_info->PushStorageFilter(&filter);
	throw_if_failed(result);
#endif

	return dev;
}

ComPtr<ID3D12CommandQueue> create_command_queue(ComPtr<ID3D12Device> dev) {
	ComPtr<ID3D12CommandQueue> command_queue;
	D3D12_COMMAND_QUEUE_DESC command_queue_desc;
	HRESULT result;

	command_queue_desc = {};

	// Very similar to Vulkan where we give a type. Note there are three
	// types of queues possible in DX12:
	// * Direct - This can be used to do draw, compute, and copy commands.
	// * Compute - Can be used to do compute and copy commands.
	// * Copy - Can be used to do only copy commands.
	command_queue_desc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	// If you have multiples queues running, the priority informs DirectX
	// which ones are the most important to get done. This would be good
	// for workloads in say VR where realtime rendering is of the utmost
	// importance.
	command_queue_desc.Priority = D3D12_COMMAND_QUEUE_PRIORITY_NORMAL;
	command_queue_desc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	// If you had multiple GPUs you wanted to use, you can use this
	// to specify which node (AKA GPU) in the topology this command
	// queue is for.
	command_queue_desc.NodeMask = 0;

	result = dev->CreateCommandQueue(
		&command_queue_desc,
		IID_PPV_ARGS(&command_queue)
	);

	throw_if_failed(result);

	return command_queue;
}

ComPtr<IDXGISwapChain3> create_swap_chain(
	HWND hwnd,
	const uint32_t screen_w,
	const uint32_t screen_h,
	ComPtr<IDXGIFactory4> factory,
	ComPtr<ID3D12CommandQueue> command_queue
) {
	ComPtr<IDXGISwapChain1> swap_chain1;
	ComPtr<IDXGISwapChain3> swap_chain3;
	DXGI_SWAP_CHAIN_DESC1 swap_chain_desc;
	HRESULT result;

	swap_chain_desc = {};
	swap_chain_desc.BufferCount = NUM_RENDER_TARGETS;
	swap_chain_desc.Width = screen_w;
	swap_chain_desc.Height = screen_h;
	swap_chain_desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	swap_chain_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swap_chain_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
	swap_chain_desc.SampleDesc.Count = 1;

	result = factory->CreateSwapChainForHwnd(
		command_queue.Get(),
		hwnd,
		&swap_chain_desc,
		NULL,
		NULL,
		&swap_chain1
	);

	throw_if_failed(result);

	//
	// After making the V1 swap chain, convert it into the desired
	// V3 swap chain.
	//

	result = factory->MakeWindowAssociation(hwnd, DXGI_MWA_NO_ALT_ENTER);
	throw_if_failed(result);

	result = swap_chain1.As(&swap_chain3);
	throw_if_failed(result);

	return swap_chain3;
}

ComPtr<ID3D12DescriptorHeap> create_descriptor_heap(
	ComPtr<ID3D12Device> dev,
	const UINT num_descriptors,
	D3D12_DESCRIPTOR_HEAP_TYPE heap_type,
	D3D12_DESCRIPTOR_HEAP_FLAGS descriptor_flags
) {
	D3D12_DESCRIPTOR_HEAP_DESC heap_desc;
	ComPtr<ID3D12DescriptorHeap> heap;
	HRESULT result;

	heap_desc = {};
	heap_desc.NumDescriptors = num_descriptors;
	heap_desc.Type = heap_type;
	heap_desc.Flags = descriptor_flags;

	result = dev->CreateDescriptorHeap(
		&heap_desc,
		IID_PPV_ARGS(&heap)
	);

	throw_if_failed(result);

	return heap;
}

void update_render_target_views(dx12_handler* dx12) {
	ComPtr<ID3D12Device> dev;
	ComPtr<IDXGISwapChain3> swap_chain;
	ComPtr<ID3D12DescriptorHeap> rtv_heap;
	UINT rtv_descriptor_size;
	D3D12_CPU_DESCRIPTOR_HANDLE descriptor_handle;
	CD3DX12_CPU_DESCRIPTOR_HANDLE rtv_handle;
	UINT i;
	HRESULT result;
	ComPtr<ID3D12Resource> back_buffer;

	dev = dx12->device;
	swap_chain = dx12->swap_chain;
	rtv_heap = dx12->rtv_heap;

	//
	// Capture the size of the rtv descriptor. This value
	// is vendor specific, so you need to query it like below.
	//

	rtv_descriptor_size = dev->GetDescriptorHandleIncrementSize(
		D3D12_DESCRIPTOR_HEAP_TYPE_RTV
	);

	dx12->rtv_descriptor_size = rtv_descriptor_size;

	//
	// Scan each back buffer and pair it with an RTV.
	//

	// To iterate over each descriptor, we get the first one using
	// this function.
	descriptor_handle = rtv_heap->GetCPUDescriptorHandleForHeapStart();

	// The CD3DX12_CPU_DESCRIPTOR_HANDLE is part of the extension of
	// DX12, and is used to make iterating over each descriptor alot
	// easier.
	rtv_handle = CD3DX12_CPU_DESCRIPTOR_HANDLE(descriptor_handle);

	for (i = 0; i < NUM_RENDER_TARGETS; i++) {
		// Get the i'th buffer.
		result = swap_chain->GetBuffer(i, IID_PPV_ARGS(&back_buffer));
		throw_if_failed(result);

		// This actually creates the RTV. The RTV needs an actual render
		// target texture (in this case, the i'th back buffer). So I
		// believe this actually hooks the next RTV descriptor to the
		// back_buffer texture to create the RTV.
		dev->CreateRenderTargetView(back_buffer.Get(), NULL, rtv_handle);
		dx12->render_targets[i] = back_buffer;

		// This increments to the next RTV descriptor.
		rtv_handle.Offset(rtv_descriptor_size);
	}
}

ComPtr<ID3D12CommandAllocator> create_command_allocator(
	ComPtr<ID3D12Device> dev,
	D3D12_COMMAND_LIST_TYPE command_list_type
) {
	ComPtr<ID3D12CommandAllocator> command_allocator;
	HRESULT result;

	result = dev->CreateCommandAllocator(
		command_list_type,
		IID_PPV_ARGS(&command_allocator)
	);

	throw_if_failed(result);

	return command_allocator;
}

ComPtr<ID3D12GraphicsCommandList> create_command_list(
	ComPtr<ID3D12Device> device,
	ComPtr<ID3D12CommandAllocator> allocator,
	D3D12_COMMAND_LIST_TYPE command_list_type
) {
	ComPtr<ID3D12GraphicsCommandList> command_list;
	HRESULT result;

	result = device->CreateCommandList(
		0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		allocator.Get(),
		// TODO: May need to pass in pipeline state object. If so,
		// we'll have to yank out the command_list as a member of
		// the dx12 handler. However, you *can* use SetPipelineStateObject,
		// so I am hoping this won't be the case.
		NULL,
		IID_PPV_ARGS(&command_list)
	);

	throw_if_failed(result);

	//
	// Lastly, we need to close the command list before we can begin
	// using it.
	//

	result = command_list->Close();
	throw_if_failed(result);

	return command_list;
}

ComPtr<ID3D12Fence> create_fence(ComPtr<ID3D12Device> device) {
	ComPtr<ID3D12Fence> fence;
	HRESULT result;

	result = device->CreateFence(
		// Initial fence value
		0,
		// Flags about the fence: is it shared with other GPU adapters? Etc.
		D3D12_FENCE_FLAG_NONE,
		IID_PPV_ARGS(&fence)
	);

	throw_if_failed(result);

	return fence;
}

HANDLE create_fence_event() {
	HANDLE fence_event;
	HRESULT err;

	fence_event = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (!fence_event) {
		err = HRESULT_FROM_WIN32(GetLastError());
		throw_if_failed(err);
	}

	return fence_event;
}

void wait_for_previous_frame(dx12_handler* dx12) {
	
	//
	// It should be noted that waiting for the frame to complete
	// before continuing is not the best practice. I think because
	// we are stalling all work on all buffers until one is done.
	// There is a tutorial D3D12HelloFrameBuffering that shows the
	// right way to do this. However, we are doing this for
	// simplicity.
	//

	UINT64 fence_val;
	ComPtr<ID3D12Fence> fence;
	ComPtr<ID3D12CommandQueue> command_queue;
	HANDLE fence_event;
	HRESULT result;

	fence_val = dx12->fence_value;
	fence = dx12->fence;
	fence_event = dx12->fence_event;
	command_queue = dx12->command_queue;

	//
	// Signal and increment the fence value.
	//

	result = command_queue->Signal(fence.Get(), fence_val);
	throw_if_failed(result);
	dx12->fence_value++;

	//
	// Now wait until the previous frame is finished.
	//

	if (fence->GetCompletedValue() < fence_val) {
		result = fence->SetEventOnCompletion(fence_val, fence_event);
		WaitForSingleObject(fence_event, INFINITE);
	}

	dx12->frame_index = dx12->swap_chain->GetCurrentBackBufferIndex();
}

void shutdown_directx_12(dx12_handler* dx12) {
	wait_for_previous_frame(dx12);
	CloseHandle(dx12->fence_event);
}